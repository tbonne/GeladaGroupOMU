package LHP;

import java.util.ArrayList;
import java.util.Collections;

import org.apache.commons.math3.linear.ArrayRealVector;
import org.apache.commons.math3.linear.RealVector;

import repast.simphony.random.RandomHelper;
import tools.SimUtils;
import tools.MoveUtils;
import jsc.distributions.Lognormal;
import cern.jet.random.*;

import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Envelope;

public class Baboon extends Primate{

	/****************************
	 * 							*
	 * Building a red colobus 	*
	 * 							*
	 * *************************/

	//initialize a primate agent
	public Baboon(int ID, Coordinate c, int groupSize, boolean isMale, int group){
		this.id = ID;
		this.coordinate = c;
		this.myGroup=group;
		if (isMale == true){
			this.sex =1; 
		} else {
			this.sex = 0;
		}
		//groupMates = new ArrayList<Primate>();
		destination = null;
		this.setFacing(RandomHelper.nextDoubleFromTo(0, 360));
		blocked=false;
		foodTarget=null;
		followMate=null;

		//vm = Parameter.vm;
		myVector = new ArrayRealVector(2,0);
	}


	/************************************
	 * 									*
	 * Stimuli (internal + external) 	*
	 * 									*
	 * *********************************/

	public void getInputs(){

		//update where the agent is on the landscapes
		this.coordinate = ModelSetup.getAgentGeometry(this).getCoordinates()[0];

		//update which patch i'm in
		this.myPatch = this.getCurrentFoodPatch();

		//update which patches i can see
		if(this.myPatch!=null){
			this.visualPatches = this.getVisibleFoodPatches(Parameter.visual_range,myPatch.visibleSites);
		} else {
			this.visualPatches = this.getVisibleFoodPatches(Parameter.visual_range);
		}


		//update my social partner of interest (attraction)
		if(followMate==null){
			Collections.shuffle(this.primateList);
			for(Primate pp : this.primateList){
				if(pp.getMyGroup()==this.getMyGroup() && pp.getId()!=this.getId()){
					followMate=pp;
					break;
				}
			}
		} else if (Math.random()<Parameter.followMateProb){
			Collections.shuffle(this.primateList);
			for(Primate pp : this.primateList){
				if(pp.getMyGroup()==this.getMyGroup() && pp.getId()!=this.getId()){
					followMate=pp;
					break;
				}
			}
		}

		//move based on attraction to food/social partners and repulsion from strangers
		attractionRepulsionRand();

	}

	/****************************
	 * 							*
	 * Behavioural response 	*
	 * 							*
	 * *************************/

	public void behaviouralResponse(){
		if(myPatch!=null){
			if(myPatch.getResourceLevel()>Parameter.biteSize){
				myPatch.eatMe(Parameter.biteSize);
			} else {
				move(myVector,true);
			}
		} else {
			move(myVector,true);
		}
	}

	/****************************
	 * 							*
	 * 		Energy updates		*
	 * 							*
	 * *************************/

	public void energyUpdate(){

		//try to eat
		/*double distMin=Parameter.foodBuffer;
		for(Cell c:visualPatches){
			double dist = c.getCoord().distance(this.getCoord());
			if(dist<distMin){
				myPatch =c;
				distMin=dist;
			}
		}*/

		//attempt to eat from current location
		
	}

	/****************************
	 * 							*
	 * 	   Behavioural model	*
	 * 							*
	 * *************************/


	private void attractionRepulsionRand(){

		//calculate the weights of each patch
		ArrayList<Double> weights = new ArrayList<Double>();
		ArrayList<RealVector> directions = new ArrayList<RealVector>();
		double sum = 0;

		for(Cell c : this.visualPatches){

			//calculate weight
			double distance = Math.max(Parameter.cellSize,  c.getCoord().distance(this.getCoord()));
			double weight = (c.getResourceLevel()) / distance;  //no effect of     *  c.getFamiliarity(this.getId() 
			weights.add(weight);
			sum = sum + weight;

			//calculate the direction
			RealVector patchVector = new ArrayRealVector(2);
			double distX = c.getCoord().x-this.getCoord().x;
			double distY = c.getCoord().y-this.getCoord().y;
			if(distX!=0 && distY!=0){
				patchVector.setEntry(0,distX);
				patchVector.setEntry(1,distY);
				patchVector.unitize();
			}
			directions.add(patchVector);
		}
		//standardize the patch weights to sum to one
		for(Double d : weights){
			d=d/sum;
		}
		//calculate the avg direction (weights*dir to each patch)
		RealVector avgFoodVector = new ArrayRealVector(2);
		for(int i = 0 ; i< weights.size();i++){
			avgFoodVector = avgFoodVector.add(directions.get(i).mapMultiply(weights.get(i)));
		}


		//calculate correlated random walk tradjectory (bearing)
		//double randomAdj = vm.nextDouble();
		//myVector.addToEntry(0, Math.cos(randomAdj));
		//myVector.addToEntry(1, Math.sin(randomAdj));

		/////calculate final direction (bearing + landscape + social)
		
		//effect of environment
		double u = Math.atan2(avgFoodVector.getEntry(1), avgFoodVector.getEntry(0));
		double length = Math.pow(Math.pow(avgFoodVector.getEntry(0),2)+Math.pow(avgFoodVector.getEntry(1), 2),0.5);
		double k = -2*Math.log(length);
		if(u==0)System.out.println("zero u");
		if(u!=0){
			u = u + VonMises.staticNextDouble(k); 
			double deltaX = Math.cos(u);
			double deltaY = Math.sin(u); 
			RealVector envVector = new ArrayRealVector(2);
			envVector.setEntry(0, deltaX);
			envVector.setEntry(1, deltaY);
			envVector.unitize();
			envVector = envVector.mapMultiply(1-Parameter.bearingWeight);
			myVector = myVector.add(envVector);
		}

		//calculate adjustment for attraction
		double distToPartner = followMate.getCoord().distance(this.getCoord());
		double magnitudeAtt = Math.max(Parameter.attractionMax*(1-(Parameter.attractionDistMax/distToPartner)),0);
		double angleToP = MoveUtils.getAngle(this.getCoord(), followMate.getCoord(),true);
		myVector.addToEntry(0, magnitudeAtt*Math.cos(angleToP));
		myVector.addToEntry(1, magnitudeAtt*Math.sin(angleToP));

		//calculate adjustment for repulsion
		for(Primate stranger:getStrangers()){
			double distToStr = stranger.getCoord().distance(this.getCoord());
			double magnitudeRep = Math.max(0, Parameter.repulsionMax*((1-(distToStr/Parameter.repulsionDistMax))));
			double angleToS = MoveUtils.getAngle(this.getCoord(), stranger.getCoord(),true);
			myVector.addToEntry(0, -magnitudeRep*Math.cos(angleToS));
			myVector.addToEntry(1, -magnitudeRep*Math.sin(angleToS));
		}

		myVector.unitize();

	}


	/****************************
	 * 							*
	 * 	   Methods				*
	 * 							*
	 * *************************/


	/*private boolean nearStranger(Coordinate coord){
		boolean retval = false;
		for(Baboon bab : this.primateList){
			if(coord.distance(bab.coordinate)<Parameter.foodAvoidanceDistance && bab.myGroup!=this.myGroup){
				retval = true;
				break;
			}
		}
		return retval;
	}*/

	private ArrayList<Primate> getStrangers(){
		ArrayList<Primate> strangers = new ArrayList<Primate>();
		for(Baboon bab : this.primateList){
			if(this.coordinate.distance(bab.coordinate)<Parameter.repulsionDistMax && bab.myGroup!=this.myGroup){
				strangers.add(bab);
			}
		}
		return strangers;
	}

	private ArrayList<Cell> getVisibleFoodPatches(double f){

		Iterable<Cell> objectsInArea = null;
		Envelope envelope = new Envelope();
		envelope.init(this.getCoord());
		envelope.expandBy(f);
		objectsInArea = ModelSetup.getGeog().getObjectsWithin(envelope,Cell.class);
		envelope.setToNull();

		ArrayList<Cell> obj = new ArrayList<Cell>();
		while(objectsInArea.iterator().hasNext()){
			Cell neigh = objectsInArea.iterator().next();
			if(neigh.getCoord().distance(this.getCoord())<f){
				obj.add(neigh);
			}
		}

		if(obj.size()<2)obj=getVisibleFoodPatches(2*Parameter.visual_range);

		return obj;
	}
	
	private ArrayList<Cell> getVisibleFoodPatches(double f, ArrayList<Cell> food){

		Iterable<Cell> objectsInArea = null;
		Envelope envelope = new Envelope();
		envelope.init(this.getCoord());
		envelope.expandBy(f);
		objectsInArea = ModelSetup.getGeog().getObjectsWithin(envelope,Cell.class);
		envelope.setToNull();

		ArrayList<Cell> obj = new ArrayList<Cell>();
		while(objectsInArea.iterator().hasNext()){
			Cell neigh = objectsInArea.iterator().next();
			if(neigh.getCoord().distance(this.getCoord())<f){
				obj.add(neigh);
			}
		}

		if(obj.size()<2)obj=getVisibleFoodPatches(2*Parameter.visual_range);

		return obj;
	}

	private Cell getCurrentFoodPatch(){

		Iterable<Cell> objectsInArea = null;
		Envelope envelope = new Envelope();
		envelope.init(this.getCoord());
		envelope.expandBy(Parameter.cellSize);
		objectsInArea = ModelSetup.getGeog().getObjectsWithin(envelope,Cell.class);
		envelope.setToNull();

		Cell myCell = null;
		double minDist = 999999;
		while(objectsInArea.iterator().hasNext()){
			Cell neigh = objectsInArea.iterator().next();
			double dist = neigh.getCoord().distance(this.getCoord());
			if(dist<minDist){
				myCell = neigh;
				minDist=dist;
			}
		}

		return myCell;
	}



	/*private boolean occupied(Coordinate coord){
		boolean retval = false;
		for(Baboon bab : this.primateList){
			if(coord.distance(bab.coordinate)<Parameter.foodBuffer && bab.getId()!=this.getId()){
				retval = true;
				break;
			}
		}
		return retval;
	}


	private synchronized void move(Coordinate destination,boolean isCellSite){
		//MoveUtils.moveToS((Primate)this, destination,0);
		if(destination.distance(this.getCoord())>0.01){
			MoveUtils.moveTo((Primate)this, destination);
			this.setCoord(ModelSetup.getAgentGeometry(this).getCoordinates()[0]);
		}
	}*/

	private synchronized void move(RealVector destination,boolean isCellSite){
		//MoveUtils.moveToS((Primate)this, destination,0);
		MoveUtils.moveTo((Primate)this, destination);
		this.setCoord(ModelSetup.getAgentGeometry(this).getCoordinates()[0]);
	}

	/*private Coordinate attractionRepulsion(){

		Coordinate dest = null;

		if(this.getId()==43){
			//System.out.println("Something here... ID 43");
		}

		//choose best food site
		double distMin = 9999;
		for (Cell food : visualPatches){
			if(nearStranger(food.coord)==false && food.getResourceLevel()>0 && occupied(food.coord)==false){
				double dist = this.coordinate.distance(food.coord);
				if(distMin>dist){
					distMin=dist;
					dest = food.coord;
				}
			}
		}

		//if no food site is available move to social partner
		if(dest == null){
			if(followMate==null){
				Collections.shuffle(this.primateList);
				for(Baboon b:primateList){
					if(this.id!=b.id && b.myGroup == this.myGroup){
						followMate=b;
						break;
					}
				}
			} else {
				dest = followMate.coordinate;
				if(this.coordinate.distance(dest)<=Parameter.bodyRadius)followMate=null;
			}
		}

		return dest;

	}*/

}