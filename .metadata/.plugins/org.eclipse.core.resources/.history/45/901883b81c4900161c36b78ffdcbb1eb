package LHP;

import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

import repast.simphony.engine.environment.RunEnvironment;
import repast.simphony.random.RandomHelper;
import tools.AngleUtils;
import tools.ForagingUtils;
import tools.GroupUtils;
import tools.SimUtils;
import tools.MoveUtils;

import com.vividsolutions.jts.geom.Coordinate;

public class Baboon extends Primate{

	/****************************
	 * 							*
	 * Building a red colobus 	*
	 * 							*
	 * *************************/

	//initialize a primate agent
	public Baboon(int ID, Coordinate c, int groupSize, boolean isMale, int group){
		this.id = ID;
		this.coordinate = c;
		this.myGroup=group;
		if (isMale == true){
			this.sex =1; 
		} else {
			this.sex = 0;
		}
		//groupMates = new ArrayList<Primate>();
		destination = null;
		this.setFacing(RandomHelper.nextDoubleFromTo(0, 360));
		blocked=false;
		foodTarget=null;
		followMate=null;
	}


	/************************************
	 * 									*
	 * Stimuli (internal + external) 	*
	 * 									*
	 * *********************************/

	public void getInputs(){

		//update where the agent is on the landscapes
		this.coordinate = ModelSetup.getAgentGeometry(this).getCoordinates()[0];

		//what food/groupmates can i see?
		try{
			visualPatches = SimUtils.getFoodInFrontOfMe(this, Parameter.visual_range);
			//visualPartners = SimUtils.getIndividualsInFrontOfMe(this, Parameter.visual_range);
		}catch (NullPointerException e){
			System.out.println("herin lies the problem 1");
		}

		//try{
		//update control variables
		//updateControlVariables();
		//}catch(NullPointerException e){
		//	System.out.println("herin lies the problem 2");
		//}

		try{
			//Make a decision as to where to move based on above information
			//destination = eco_social_tradeoff();
			destination = attractionRepulsion();
		} catch (NullPointerException e){
			System.out.println("herin lies the problem 3" + " "+ this.actionTaken + " "+ this.id);
		}
	}

	/****************************
	 * 							*
	 * Behavioural response 	*
	 * 							*
	 * *************************/

	public void behaviouralResponse(){

		if(destination!=null){

			//move towards destination
			move(destination,true); 

		} else {
			//rest
		}

		destination = null;
	}

	/****************************
	 * 							*
	 * 		Energy updates		*
	 * 							*
	 * *************************/

	public void energyUpdate(){

		//try to eat
		double distMin=Parameter.foodBuffer;
		for(Cell c:visualPatches){
			double dist = c.getCoord().distance(this.getCoord());
			if(dist<distMin){
				myPatch =c;
				distMin=dist;
			}
		}
		//attempt to eat from current location
		if(myPatch!=null){
			double bite = myPatch.eatMe(Parameter.biteSize-50);
			followMate=null;
		}
		myPatch=null;
	}

	/****************************
	 * 							*
	 * 	   Behavioural model	*
	 * 							*
	 * *************************/

	private Coordinate attractionRepulsion(){

		Coordinate dest = null;

		//choose best food site
		double distMin = 9999;
		for (Cell food : visualPatches){
			if(nearStranger(food.coord)==false){
				double dist = this.coordinate.distance(food.coord);
				if(distMin>dist){
					distMin=dist;
					dest = food.coord;
				}
			}
		}

		//if no food site is available move to social partner
		if(dest == null){
			if(followMate==null){
				Collections.shuffle(this.primateList);
				for(Baboon b:primateList){
					if(this.id!=b.id && b.myGroup == this.myGroup){
						followMate=b;
						break;
					}
				}
			} else {
				dest = followMate.coordinate;
			}
		}

		return dest;

	}

	private boolean nearStranger(Coordinate coord){
		boolean retval = false;
		for(Baboon bab : this.primateList){
			if(coord.distance(bab.coordinate)<Parameter.foodAvoidanceDistance){
				retval = true;
				break;
			}
		}
		return retval;
	}


	private Coordinate eco_social_tradeoff(){
		actionTaken=0;


		Coordinate dest = null;
		//if(noise==0){
		if(control_exposure>Parameter.exposure_threshold && control_distMR>Parameter.minDist_MR){ 
			actionTaken=3; //minimize exposure
		} else {

			//if(control_optForaging>0.05){
			actionTaken=1; //maximize foraging potential
			//} else {
			//actionTaken=2;
			//}
		}
		//} else {
		//	actionTaken=1;
		//}

		noise=1;
		////////////////////////
		//perform chosen action
		////////////////////////

		//Maximize foragin potential: fixed behaviour -> move towards open space
		if(actionTaken==1){ 
			//move to optimize foraging
			//dest = GroupUtils.moveToOptimzeForaging(this);
			if(control_hunger==true){
				//if(this.visualPatches.size()>0)	dest = ForagingUtils.findBestUnknownFoodSource(this);
				//if(control_hunger>0.5){
				//if(foodTarget==null){
				dest = ForagingUtils.findBestUnknownFoodSource(this);
				//} else {

				//	if(foodTarget.distance(this.getCoord())<=Parameter.bodyRadius){
				//		foodTarget=null;
				//	}
				//	dest = ForagingUtils.findBestUnknownFoodSource(this,foodTarget);
				//dest = foodTarget;


				//	}
			} else {
				//move to social
				if(this.getCoord().distance(followMate.getCoord())>Parameter.bodyRadius){
					dest=followMate.getCoord();
					//System.out.println("I'm "+ this.id +" moving towards "+followMate.id);
					socialCount++;
				}
			}
		} 

		//face direction of individual in sight
		//if(actionTaken==2){	
		//dest = GroupUtils.faceDirectionOfGroupMate(this);



		//}

		//Minimize exposure: fixed behaivour -> move towards the noisiest direction (mean angle)
		if(actionTaken==3){

			foodTarget=null;
			//calculate mean resulting vector of noise
			dest = GroupUtils.getMeanResultantAngle(this);
			//if(GroupUtils.getNumbGroupMatesNearCoord(this, dest)>0)dest=null;

			//dest = GroupUtils.betweenTwoNearestNeigh(this);
		}
		return dest;
	}

	/****************************
	 * 							*
	 * 	   Methods				*
	 * 							*
	 * *************************/

	private void updateControlVariables(){
		//exposure (position of noisy groupmates)
		control_exposure = GroupUtils.getMeanResultant(this);
		//control_exposure = GroupUtils.getNumbGroupMatesWithinForaging(this);

		control_distMR = GroupUtils.getMeanResultantDist(this);

		//foraging potential (open area available)
		//control_optForaging = GroupUtils.getForagingValueOfPosition(this);

		//social (constant increase while no association in sight)
	}

	private synchronized void move(Coordinate destination,boolean isCellSite){
		//MoveUtils.moveToS((Primate)this, destination,0);
		if(destination.distance(this.getCoord())>0.01){
			MoveUtils.moveTo((Primate)this, destination,actionTaken);
			this.setCoord(ModelSetup.getAgentGeometry(this).getCoordinates()[0]);
		}
	}

}