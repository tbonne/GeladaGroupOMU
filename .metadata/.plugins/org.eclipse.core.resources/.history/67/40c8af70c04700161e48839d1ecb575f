package LHP;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;

import org.geotools.referencing.GeodeticCalculator;

import jsc.distributions.Lognormal;
import jsc.distributions.Normal;

import cern.jet.random.Uniform;

import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.Point;

import repast.simphony.context.Context;
import repast.simphony.context.space.gis.GeographyFactory;
import repast.simphony.context.space.gis.GeographyFactoryFinder;
import repast.simphony.dataLoader.ContextBuilder;
import repast.simphony.engine.environment.RunEnvironment;
import repast.simphony.engine.schedule.ISchedule;
import repast.simphony.engine.schedule.ScheduleParameters;
import repast.simphony.engine.schedule.ScheduledMethod;
import repast.simphony.random.RandomHelper;
import repast.simphony.space.gis.Geography;
import repast.simphony.space.gis.GeographyParameters;
import tools.GroupUtils;
import tools.SimUtils;

//This file builds the model: creating the environment and populating it with primates
public class ModelSetup implements ContextBuilder<Object>{

	private static Context mainContext;
	private static Geography geog;
	private static int sitesAdded;
	private static double resAdded;
	public static int primatesAdded;
	public static ArrayList<Primate> primatesAll,orderedP;
	public static Iterable<Primate> primateIterator;
	public static ArrayList<Cell> cellsToUpdate;
	public static ArrayList<Cell> removeCellsToUpdate;
	public static ArrayList<Cell> allCells;
	public static double timeRecord;
	public static double timeRecord_start;
	public static GeodeticCalculator gc;

	public Context<Object> build(Context<Object> context){

		System.out.println("Running movement pattern simulation model");

		/********************************
		 * 								*
		 * initialize model parameters	*
		 * 								*
		 * ******************************/

		sitesAdded = 0;
		resAdded=0;
		primatesAdded = 0;
		primatesAll= new ArrayList<Primate>();
		orderedP = new ArrayList<Primate>();
		mainContext = null;
		Parameter parameter = new Parameter();
		geog=null;
		cellsToUpdate = new ArrayList<Cell>();
		removeCellsToUpdate = new ArrayList<Cell>();
		allCells = new ArrayList<Cell>();
		mainContext = context; //static link to context
		timeRecord = System.currentTimeMillis();
		timeRecord_start = System.currentTimeMillis();

		/****************************
		 * 							*
		 * Building the landscape	*
		 * 							*
		 * *************************/

		//Create Geometry factory; used to create gis shapes (points=primates; polygons=resources)
		GeometryFactory fac = new GeometryFactory();

		//x and y dims of the map file
		int xdim = Parameter.landscapeWidth;
		int ydim = Parameter.landscapeWidth;

		//Create Geography/GIS 
		GeographyParameters<Object> params= new GeographyParameters<Object>();
		GeographyFactory factory = GeographyFactoryFinder.createGeographyFactory(null);
		geog = factory.createGeography(Parameter.geog, context, params);
		geog.setCRS("EPSG:32636"); //WGS 84 / UTM zone 36N EPSG:32636
		gc = new GeodeticCalculator(geog.getCRS());

		//Add Resources to the environment *****************************************//
		System.out.println("adding resources to the environment");
		Uniform xDist = RandomHelper.createUniform(0, xdim);
		Uniform yDist = RandomHelper.createUniform(0, ydim);
		int count=0;
		for(int i=0;i<Parameter.foodDensity*xdim*ydim;i++){
			Cell cell = new Cell(context,xDist.nextDouble(),yDist.nextDouble(),Parameter.food,count++);
			resAdded=resAdded+Parameter.food;
			sitesAdded++;
			allCells.add(cell);
		}

		/************************************
		 * 							        *
		 * Adding hosts to the landscape	*
		 * 							        *
		 * *********************************/

		//keep track of groups being added
		ArrayList<Primate> group = new ArrayList<Primate>();

		//center of group (fixed)
		double xCenter =xdim/2;//0;//xDist.nextDouble();//75;//1000;// 75;
		double yCenter =ydim/2;//0;//yDist.nextDouble();// -75;//-1000;//-75;

		for(int i = 0 ;i<Parameter.numbOfGroups;i++ ){

			//select the number of primates in this group (fixed)
			int groupSize = Parameter.rcGroupSize;

			boolean isMale = true;

			//add individuals
			for (int j = 0; j < groupSize; j++){
				
				//add individual
				Coordinate coord=null;
				Baboon rc = new Baboon(primatesAdded++,coord,groupSize,isMale);
				isMale=false;
				context.add(rc);
				primatesAll.add(rc);
				orderedP.add(rc);
				group.add(rc);
				Point geom = fac.createPoint(coord);
				geog.move(rc, geom);
				rc.myPatch = null;
			}
		}

		//Add groupMates list (for simulation control)
		//for(Primate p:primatesAll){
		//	p.groupMates=primatesAll;
		//}

		//Add a follower for each individual: when not hungry or exposed, move towards this individual. 
		for(Primate p:orderedP){
			//System.out.println("starting with "+p.id);
			if(p.getId()==0)p.setBaboonFollower(2);
			if(p.getId()==1)p.setBaboonFollower(2);
			if(p.getId()==2)p.setBaboonFollower(3);
			if(p.getId()==3)p.setBaboonFollower(0);
			if(p.getId()==4)p.setBaboonFollower(5);
			if(p.getId()==5)p.setBaboonFollower(6);
			if(p.getId()==6)p.setBaboonFollower(12);
			if(p.getId()==7)p.setBaboonFollower(8);
			if(p.getId()==8)p.setBaboonFollower(7);
			if(p.getId()==9)p.setBaboonFollower(8);
			if(p.getId()==10)p.setBaboonFollower(8);
			if(p.getId()==11)p.setBaboonFollower(12);
			if(p.getId()==12)p.setBaboonFollower(13);
			if(p.getId()==13)p.setBaboonFollower(11);

			//p.setBaboonFollowerRand(p);
			//p.setBaboonFollowerLeader();
		}

		for(Primate p:this.getAllPrimateAgents()){
			System.out.println("I'm "+p.id+ " following " + p.followMate.id);
		}



		/************************************
		 * 							        *
		 * create the scheduling			*
		 * 							        *
		 * *********************************/

		// Ordering processes
		// (1) get inputs for agents						- threaded
		// (2) behavioural responses of agents (movement) 	- threaded
		// (3) behavioural responses of agents (energy)		- threaded
		// (4) environment growback							- threaded
		// (5) add/remove cells to modify					- not threaded

		//executor takes care of the processing of the schedule
		Executor executor = new Executor();
		createSchedule(executor);

		/************************************
		 * 							        *
		 * Adding watcher agent				*
		 * 							        *
		 * *********************************/

		//watcher agent records all output
		Watcher w = new Watcher(executor);
		context.add(w);

		return context;

	}

	private void createSchedule(Executor executor){

		ISchedule schedule = RunEnvironment.getInstance().getCurrentSchedule();

		if(Parameter.groupProcess==true){ //subgroups of agents passed through each separate process, then next subgroup processed

			ScheduleParameters agentStepParamsPrimate = ScheduleParameters.createRepeating(1, 1, 6); //start, interval, priority (high number = higher priority)
			schedule.schedule(agentStepParamsPrimate,executor,"processPrimates");

		} else {  //all agents passed through separate process, one process at a time

			ScheduleParameters agentStepParamsPrimate = ScheduleParameters.createRepeating(1, 1, 6); //start, interval, priority (high number = higher priority)
			schedule.schedule(agentStepParamsPrimate,executor,"getInputs");

			ScheduleParameters agentStepParamsPrimateBehaviour = ScheduleParameters.createRepeating(1, 1, 5); //start, interval, priority (high number = higher priority)
			schedule.schedule(agentStepParamsPrimateBehaviour,executor,"behaviour");

			ScheduleParameters agentStepParamsPrimateEnergy = ScheduleParameters.createRepeating(1, 1, 4); //start, interval, priority (high number = higher priority)
			schedule.schedule(agentStepParamsPrimateEnergy,executor,"energyUpdate");

		}

		ScheduleParameters agentStepParams = ScheduleParameters.createRepeating(1, 1, 2);
		schedule.schedule(agentStepParams,executor,"envUpdate");
	}


	//used to update only the cells which have been modified, have parasites, or are growing back
	@ScheduledMethod(start=1, interval = 1,priority=1)
	public static void removeCellsUpdated(){
		for(Cell c : removeCellsToUpdate){
			cellsToUpdate.remove(c);
		}
		removeCellsToUpdate.clear();
	}

	//used to convert DBH to food values in the model
	private void setTotalResources(int numbCells){
		//calculate the percent difference between the total resource level now and the target level
		double targetRes = numbCells*Parameter.foodDensity;
		double perDiff = (double)resAdded / (double)targetRes;
		double newTotal=0;
		int count=0;

		//Divide each resource by the percent difference to make the total equal the target resource amount
		for (Cell c : getAllCellAgents()){
			c.setMaxResourceLevel(((double)c.getMaxResourceLevel()/(double)perDiff));
			c.setResourceLevel(((double)c.getResourceLevel()/(double)perDiff));
			newTotal = newTotal + c.getResourceLevel();
			count++;
		}
	}


	public static void stopSim(Exception ex, Class<?> clazz) {
		ISchedule sched = RunEnvironment.getInstance().getCurrentSchedule();
		sched.setFinishing(true);
		sched.executeEndActions();
	}

	public static Iterable<Cell> getAllCellAgents() {
		return allCells;
	}

	public static Iterable<Primate> getAllPrimateAgents(){
		Collections.shuffle(primatesAll, new Random(System.currentTimeMillis()));
		Iterable<Primate> agents = primatesAll;
		return agents;
	}

	public static Iterable<Primate> getAllPrimateAgentsInOrder(){
		Iterable<Primate> agents = primatesAll;
		return agents;
	}

	public static Context<Cell> getContext() {
		return ModelSetup.mainContext;
	}
	public static Geography<Primate> getGeog(){
		return geog;
	}
	public synchronized static void addToCellUpdateList(Cell c){  //need to read up on the synchronized implimentation
		if(cellsToUpdate.contains(c)==false)cellsToUpdate.add(c);
	}
	public synchronized static void removeCellToUpdate(Cell c){
		removeCellsToUpdate.add(c);
	}
	public static ArrayList<Cell> getCellsToUpdate(){
		return cellsToUpdate;
	}
	public static <T> Geometry getAgentGeometry(T agent) {
		return getGeog().getGeometry(agent);
	}
	public static Primate getGroupLeader(){
		return groupLeader;
	}
	public static GeodeticCalculator getGC(){
		return gc;
	}

}
