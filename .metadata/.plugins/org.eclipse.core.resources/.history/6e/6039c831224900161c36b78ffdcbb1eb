package tools;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

import repast.simphony.context.Context;
import repast.simphony.engine.environment.RunEnvironment;
import repast.simphony.random.RandomHelper;
import repast.simphony.space.gis.Geography;
import repast.simphony.util.ContextUtils;

import LHP.Cell;
import LHP.ModelSetup;
import LHP.Parameter;
import LHP.Primate;
import LHP.Baboon;
import LHP.Watcher;

import com.vividsolutions.jts.geom.Coordinate;

public final strictfp class GroupUtils {
	
	/* Method list:
	 * 		(1)	optimize foraging potential (move towards open space)
	 * 		(2) minimize exposure (move towards noisiest area)
	 * 		(3) control variable: exposure
	 * 		(4) control variable: foraging optimality 
	 */
	
	
	
	/******************************************************behaviours*********************************************************/
	
	//(1) move towards open area
	public static Coordinate moveToOptimzeForaging(Primate primate){  
		Coordinate dest=null;
		
		//find food sites 
		List<Cell> foodPatches = primate.getVisualPatches();
		
		//find most open visual area 
		double[] angles = AngleUtils.getLargestOpenArc(primate);
		
		//find closest food within open area
		double minDist=Parameter.visual_range;
		Cell bestC=null;
		for(Cell c:foodPatches){
			double dist = primate.getCoord().distance(c.getCoord());
			double angleToC = AngleUtils.getAngle(primate.getCoord(), c.getCoord());
			if(AngleUtils.withinAngles(primate.getFacing(),angleToC)||dist<Parameter.bodyRadius){
				if(dist<minDist && c.getResourceLevel()>0){
					bestC = c;
					minDist=dist;
				}
			}
		}
		
		if(bestC != null){ 
			dest=bestC.getCoord();
		} else{
			double avgAngle = AngleUtils.getMiddleAngle(angles); 
			dest = new Coordinate(primate.getCoord().x+Math.cos(Math.toRadians(avgAngle))*Parameter.maxDistancePerStep/Parameter.redicedForagingSpeed,primate.getCoord().y+Math.sin(Math.toRadians(avgAngle))*Parameter.maxDistancePerStep/Parameter.redicedForagingSpeed);
		}
		return dest;
	}
	
	//(2) move towards noise
	public static Coordinate getCenterCoord(Primate primate){
		
		int count=0;
		
		double x=0,y=0;
		
		for (Primate groupMate: ModelSetup.primatesAll){

			//double dist = primate.getCoord().distance(groupMate.getCoord());
			if( groupMate.getId()!=primate.getId()){ //groupMate.getNoise()==1 && 
				
				x=x+(groupMate.getCoord().x);
				y=y+(groupMate.getCoord().y);
				count++;
			}
		}
		x=x/(double)count;
		y=y/(double)count;
		
		Coordinate target = new Coordinate(x,y);
		double avgAngle = AngleUtils.getAngle(primate.getCoord(),target); 
		Coordinate coord = new Coordinate(primate.getCoord().x+Math.cos(Math.toRadians(avgAngle))*Parameter.maxDistancePerStep,primate.getCoord().y+Math.sin(Math.toRadians(avgAngle))*Parameter.maxDistancePerStep);
		
		return coord;
	}
	
	/********************************************************************control variables******************************************************************/
	
	//(3) control variable: exposure
	public static double getMeanResultant(Primate primate){
		
		double cosAngle=0,sinAngle=0;
		int count=0;
		//double tot_dist=0;
		
		for (Primate groupMate: ModelSetup.primatesAll){
		//for (Primate groupMate: getClosestGM(primate,Parameter.topologyNN)){
			

			//double dist = primate.getCoord().distance(groupMate.getCoord());
			if( groupMate.getId()!=primate.getId() ){//&& groupMate.getNoise()==1 && dist < Parameter.audioRange &&
			//if(groupMate.getId()!=primate.getId()){
				
				double angle = Math.toRadians(AngleUtils.getAngle(primate.getCoord(),groupMate.getCoord()));
				cosAngle = cosAngle + Math.cos(angle);///Math.pow(dist,2);
				sinAngle = sinAngle + Math.sin(angle);///Math.pow(dist,2);
				count++;
				//tot_dist=tot_dist+1/(Math.pow(dist,2));
			}
		}
		
		double mR = Math.pow( Math.pow(cosAngle,2) + Math.pow(sinAngle,2) , 0.5) / ((double)count);
		//mR = mR/ Math.pow(tot_dist,2);
		if(Double.isNaN(mR))mR=0;
		if(count<=2)mR=0;
		return mR;
	}
	
	private static ArrayList<Primate> getClosestGM(Primate primate, int ind){
		
		ArrayList<Primate> neigh = new ArrayList<Primate>();
		
		for(int i=0;i<ind;i++){
			double minDist = 99999;
			for(Primate p : ModelSetup.primatesAll){
				double dist = p.getCoord().distance(primate.getCoord());
				if(minDist>dist && neigh.contains(p)==false){
					neigh.add(p);
					minDist=dist;
				}
			}
		}
		
		return neigh;
	}
	
	//response to reduce exposure variable
	public static Coordinate getMeanResultantAngle(Primate primate){
		Coordinate coord=null;
		double cosAngle=0,sinAngle=0;
		int count=0;
		//double tot_dist=0;
		
		if(primate.getId()==5){
			//System.out.println("");
		}
		
		for (Primate groupMate: ModelSetup.primatesAll){
		//for (Primate groupMate:getClosestGM(primate,Parameter.topologyNN) ){

			//double dist = primate.getCoord().distance(groupMate.getCoord());
			if( groupMate.getId()!=primate.getId() ){//&&groupMate.getNoise()==1 &&dist < Parameter.audioRange && 
			//if(groupMate.getId()!=primate.getId()){
				
				double angle = Math.toRadians(AngleUtils.getAngle(primate.getCoord(),groupMate.getCoord()));
				cosAngle = cosAngle + Math.cos(angle);///Math.pow(dist,2);
				sinAngle = sinAngle + Math.sin(angle);///Math.pow(dist,2);
				count++;
				//tot_dist=tot_dist+1/(Math.pow(dist,2));
			}
		}
		Coordinate headingC = new Coordinate(primate.getCoord().x+cosAngle,primate.getCoord().y+sinAngle);
		double mRAngle = Math.toRadians(AngleUtils.getAngle(primate.getCoord(),headingC));
		
		if(Double.isNaN(mRAngle)){
			System.out.println("something wrong with the angle calculation in getMeanResultantAngle code");
		}else{
			//coord = new Coordinate(primate.getCoord().x+cosAngle,primate.getCoord().y+sinAngle);
			coord = new Coordinate(primate.getCoord().x+Math.cos(mRAngle)*Parameter.maxDistancePerStep,primate.getCoord().y+Math.sin(mRAngle)*Parameter.maxDistancePerStep);
		}
		
		
		//nobody within earshot turn around
		/*if(count==0){
			double opposite = primate.getFacing();
			opposite = opposite +180;
			if(opposite>360)opposite=opposite-360;
			coord = new Coordinate(primate.getCoord().x+Math.cos(opposite)*Parameter.maxDistancePerStep,primate.getCoord().y+Math.sin(opposite)*Parameter.maxDistancePerStep);
		}*/
		
		return headingC;
	}
	
	public static double getMeanResultantDist(Primate primate){
		Coordinate coord=null;
		double xDist=0,yDist=0,sinAngle=0;
		double dist=0;
		//double tot_dist=0;
		
		if(primate.getId()==5){
			//System.out.println("");
		}
		
		for (Primate groupMate: ModelSetup.primatesAll){
		//for (Primate groupMate:getClosestGM(primate,Parameter.topologyNN) ){

			//double dist = primate.getCoord().distance(groupMate.getCoord());
			if( groupMate.getId()!=primate.getId() ){//&&groupMate.getNoise()==1 &&dist < Parameter.audioRange && 
			//if(groupMate.getId()!=primate.getId()){
				
				//double angle = Math.toRadians(AngleUtils.getAngle(primate.getCoord(),groupMate.getCoord()));
				dist = dist + primate.getCoord().distance(groupMate.getCoord());
				xDist = Math.abs(primate.getCoord().x-groupMate.getCoord().x);
				yDist = Math.abs(primate.getCoord().y-groupMate.getCoord().y);
				//tot_dist=tot_dist+1/(Math.pow(dist,2));
			}
		}
		
		return 	dist;//Math.max(xDist, yDist);
	}
	
	public static double getNumbGroupMatesWithinForaging(Primate primate){
		double exp = 0;
		
		for(Primate pG : ModelSetup.primatesAll){
			if(pG.getId()!=primate.getId()){
			double distance = pG.getCoord().distance(primate.getCoord());
			if(distance<Parameter.visual_range)exp=exp+1;
			}
		}
		
		return exp;
	}
	
	public static double getNumbGroupMatesNearCoord(Primate primate,Coordinate c){
		double exp = 0;
		
		for(Primate pG : ModelSetup.primatesAll){
			if(pG.getId()!=primate.getId()){
			double distance = pG.getCoord().distance(primate.getCoord());
			if(distance<Parameter.bodyRadius)exp=exp+1;
			}
		}
		
		return exp;
	}
	
	//response to control exposure (move between two nearest neighbours
	/*public static Coordinate betweenTwoNearestNeigh(Primate primate){
		
		Coordinate dest = null;
		
		
		//find closest p (audio)
		Primate audioP1 = null;
		double minDist = Parameter.audioRange, dist=Parameter.audioRange;
		for(Primate groupMate:primate.getGroupMates()){
			dist = groupMate.getCoord().distance(primate.getCoord());
			if(dist < minDist && groupMate.getId()!=primate.getId()){
				minDist = dist;
				audioP1=groupMate;
			}
		}
		//find second closest p (audio)
		Primate audioP2 = null;
		double minDist2 = Parameter.audioRange, dist2=Parameter.audioRange;
		for(Primate groupMate2:primate.getGroupMates()){
			dist2 = groupMate2.getCoord().distance(primate.getCoord());
			if(dist2 < minDist2 && groupMate2.getId()!= audioP1.getId() && groupMate2.getId()!=primate.getId()){
				minDist2 = dist2;
				audioP2=groupMate2;
			}
		}
		
		if(audioP1!=null){
			if(audioP2!=null){
				double avgx=0,avgy=0;
				avgx = (audioP1.getCoord().x+audioP2.getCoord().x)/2.0;
				avgy = (audioP1.getCoord().y+audioP2.getCoord().y)/2.0;
				dest = new Coordinate(avgx,avgy);
			} else {
				dest = audioP1.getCoord();
			}
		}
		return dest;
	}*/
	
	
	//control variable: foraging optimality
	public static double getForagingValueOfPosition(Primate primate){
		
		double range = AngleUtils.getRangeAngle(AngleUtils.getLargestOpenArc(primate));
		double optForaging = 1-(range/(double)Parameter.visualArc);
		
		//int count = getNumbAgentsWithinForagingRange(primate);
		//return count/((double)primate.getGroupMates().size()-1);
		
		return optForaging;
	}
	
	/**********************************************************************generic methods******************************************************************/
	
	public static Coordinate faceDirectionOfGroupMate(Primate primate){
		
		Coordinate dest=null;
		//choose random individual within view
		List<Primate> visP = primate.getVisualPartners();
		Collections.shuffle(visP);
		
		if(visP.size()>0){
			//if found, turn to face target
			Primate mimicP = visP.get(0);
			
			//get difference in angles
			double[] angles  ={primate.getFacing(),mimicP.getFacing()};
			double angleDiff = AngleUtils.getRangeAngle(angles);
			if(angleDiff>Parameter.turnSpeed){
			//moveUtils does have a method for turing
			primate.setFacing(mimicP.getFacing());
			} else {
				//dest = moveToOptimzeForaging(primate);
				primate.setFacing(mimicP.getFacing());
			}
		} else {
			dest = moveToOptimzeForaging(primate);
		}
		
		return dest;
		
	}
	
	public static Coordinate followGroupMate(Primate primate){
		
		Coordinate dest=null;
		//choose random individual within view
		List<Primate> visP = primate.getVisualPartners();
		Collections.shuffle(visP);
		
		if(visP.size()>0){
			//if found, turn to face target
			Primate mimicP = visP.get(0);
			dest = mimicP.getCoord();
			
		} else {
			dest = moveToOptimzeForaging(primate);
		}
		
		return dest;
		
	}
	
	
	

	/*
	public static double[] getOpenArea(double facing, Coordinate start, ArrayList<Coordinate> coords){
		
		double[] angles = new double[2];
		ArrayList<Double> allAngles = new ArrayList<Double>();
		
		//get all angles (start and end are the limits to visual range)
		double initalAngle = getInitialAngle(facing);
		double finalAngle = getFinalAngle(facing);
		
		//add all angles 
		//List<Primate> visP = primate.getVisualPartners();
		allAngles.add(initalAngle);
		for(Coordinate c:coords){
			allAngles.add((double) getAngle(start,c));
		}
		allAngles.add(finalAngle);
		
		//order them
		if(Math.abs(initalAngle-finalAngle)>Parameter.visualArc){
			//crosses 0
			double minA = Math.min(angles[0], angles[1]);
			double maxA = Math.max(angles[0], angles[1]);
			minA=minA+360;
			ArrayList<Double> allAnglesT = new ArrayList<Double>();
			for(Double d:allAngles){
				if(d<maxA)d=d+360;
				allAnglesT.add(d);
			}
			Collections.sort(allAnglesT,Collections.reverseOrder());
			
			//find the largest gap
			double maxRange = 0,startA = allAnglesT.get(0),endA=0;
			double maxAstart=0,maxAend=0;
			for(Double d:allAnglesT){
				endA=d;
				double[] span = {startA,endA};
				double distA = getRangeAngle(span);
				if(distA>maxRange){
					maxAstart=startA;
					maxAend=endA;
					maxRange=distA;
				}
				startA=endA;
			}
			
			if(maxAstart>360)maxAstart=maxAstart-360;
			if(maxAend>360)maxAend=maxAend-360;
			angles[0]=maxAstart;
			angles[1]=maxAend;
			
		} else {
			Collections.sort(allAngles,Collections.reverseOrder());

			//find the largest gap
			double maxA = 0,startA = allAngles.get(0),endA=0;
			double maxAstart=0,maxAend=0;
			for(Double d:allAngles){
				endA=d;
				double[] span = {startA,endA};
				double distA = getRangeAngle(span);
				if(distA>maxA){
					maxAstart=startA;
					maxAend=endA;
					maxA=distA;
				}
				startA=endA;
			}
			angles[0]=maxAstart;
			angles[1]=maxAend;
		}
		
		return angles;
	}
	*/
	
	
}
